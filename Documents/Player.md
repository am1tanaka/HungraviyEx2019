# プレイヤー

シーン遷移、モック画面ができたら、ゲームの中身の開発を開始します。

![モック画面](Images/Mock00.png)

真っ先に手を付けたいのは、ゲームの要となるプレイヤーの操作です。チーム開発なら、ステージの作成、敵の作成、マップの仕掛けの作成も始められます。以下の流れと同様に検討して、進めていくとよいでしょう。

## 仕様を決める
コードを書く前に作るものの詳細を決めます。プログラミング慣れしている人は、ある程度の内容であればいきなり開発を始めても完成させることができます。しかし、それは暗算と同じことなので頭の中でまとめられる範囲のものにしか対応できません。暗算より筆算の方がはるかに複雑な問題を解くことができるのと同様で、これから作ろうとしているものを書き出すことで、様々なプログラミング的な課題に対応できるようになります。

### 操作方法
操作方法をまとめます。

- マウスのボタンを押すと、マウスカーソルの場所にブラックホールが発生する
- ドラッグで、ブラックホールはマウスカーソルの場所を目指して移動
- マウスのボタンを離すと、ブラックホールは消滅
- ESCキーでゲームを一時停止

操作を書き出すと分かりますが、主人公はぐらびぃですが、操作するのはブラックホールです。ブラックホールから先に作った方が合理的です。

### ブラックホールの状態を決める
ゲームの状況によって、操作と動きが切り替わることがあります。そのような動きを作りやすくするために、ゲーム中にどのような状態があるかを決めて、変数などで管理するのが一般的です。状態を切り替えることを**状態遷移**(じょうたいせんい)と呼びます。状態を英語でいうと**State**(ステート)です。状態を切り替えながら動作する仕組みのことを**State Machine**(ステートマシーン)といいます。UnityのAnimatorはState Machineです。

まずは、ゲームがスタートしてからの流れでどのようなことがブラックホールに起き得るかをリストアップします。

- ステージシーンがフェードイン。Go!の文字が表示されるまで操作不可
- Go!の表示後、何もしないとそのまま待機
- マウスボタンを押すと、ブラックホール発生
- エネルギーがなくなると消える
- マウスの操作で動く
- マウスのボタンを離すと消える
- クリアすると消える
- ゲームオーバーになるとそのままの状態で操作不可
- ポーズ中はそのままの状態で操作不可

以上から、状態を切り分けます。操作と動きを基準に検討していきます。

- 操作不能状態
  - Go!が開始される前
  - ゲームオーバー
  - クリア
  - ポーズ中
- ブラックホールが発生していない状態
  - 操作可能で、ボタンが押されていない
  - エネルギーがない
- ブラックホール発生中
  - 操作可能で、ボタンが押されている
  - エネルギーが残っている

状態はかなりシンプルです。

- 操作が可能な時にtrueを返すboolフラグ
- エネルギーの値
- マウスのボタンが押されているかどうか

以上の3つのパラメーターで制御できそうです。この程度の数ならば、パラメーターで直接制御した方がシンプルに実装できそうです。

状態が数種類以上あり、お互いの遷移が複雑な場合はフラグを個別にチェックする方法だと複雑さが増して制御が難しくなります。その場合は、enumなどで状態を宣言して、状態を切り替えて制御します。

### アニメーションの状態を決める
UnityのAnimatorコントローラーを活用する場合は、アニメーションの状態も決めます。

- 何も発生していない
- ブラックホールが発生するアニメ
- ブラックホールが出続けているアニメ
- ブラックホールが消えるアニメ

上記の4つの状態があります。これが切り替わるきっかけが何かを決めます。

- 何も発生していない
  - 発生する指示があったら発生へ
- ブラックホールが発生するアニメ
  - アニメの再生が終わったら自動的に、出続けているアニメへ
- ブラックホールが出続けているアニメ
  - 発生する指示がなくなったら、消えるアニメへ
- ブラックホールが消えるアニメ
  - アニメの再生が終わったら自動的に、何も発生していない状態へ

ここで気にしておきたいのが、ブラックホールが発生途中でボタンが離されたらどうなるのか。その逆の、ブラックホールが消えるアニメ中にまた発生するとどうなるのか。この2点です。

ブラックホールが発生中でもそのまま消えるアニメに移行させる方法と、発生するアニメが完了するのを待ってから消し始める2通りが考えられます。前者の方がテキパキ動きますが、アニメの途中から他のアニメに自然につなぐのは2Dではどこまで再生したのかの管理が必要なので工数が増えます。

詳細を詰めていくと、このような動かし方の違いが出てきます。その場合、まずは工数が少ない方で実装してみるのが良策です。動かしてみて問題がなければ、余計な工数をかけなくて済んだことになります。勿論、やはり駄目だね、となる場合もあります。その場合でも、無駄になる工数は少ないのでリスクを減らせます。

以上から、アニメを終えてから切り替えれる方法でまずは実装します。必要なパラメーターは、ブラックホールが発生しているかどうかのbool値だけです。trueなら、何も発生していない状態からブラックホール発生アニメに切り替え、falseなら、出続けているアニメから消えるアニメに切り替えます。

# アニメーションを作る
開発は、出力から作ると楽です。TDD(Test Driven Development)というのがありますが、考え方は同様です。目指すゴールから作っていく訳です。今回はアニメーション画像があるので、アニメ部分から作るのがよいでしょう。

## Animatorの作成
Projectウィンドウで*Create* > *Animator Controller*を作成して、`Blackhole`などの名前にします。既存のテスト用のものがあったら、削除して作り直します。

パラメーターは、*bool*型で、名前は`Spawn`としました。状態は以下のように作成しました。

![Blackholeアニメーター](Images/Blackhole00.png)

トランザクションは以下の通りです。

### HidedからSpawn

![HidedからSpawn](Images/Blackhole01.png)

- Has Exit Timeのチェックを外す
- Transition Durationを0
- ConditionsをSpawn、true設定

### SpawnからSpawned

![SpawnからSpawned](Images/Blackhole02.png)

- Has Exit Timeにチェック
- Exit Timeを1
- Transaction Durationを0

### SpawnedからDestroy

![SpawnedからDestroy](Images/Blackhole03.png)

- Has Exit Timeのチェックを外す
- Transition Durationを0
- ConditionsをSpawn、false設定

### DestroyからHided

![DestroyからHided](Images/Blackhole04.png)

- Has Exit Timeにチェック
- Exit Timeを1
- Transaction Durationを0

## 動作確認
動きを確認します。

- Systemシーンをダブルクリックして開いたらPlayします
- Titleでクリックしてゲームを開始します
- HierarchyウィンドウでBlackholeオブジェクトをクリックして選択します
- WindowメニューからAnimation > Animatorを選択して、Animatorウィンドウを開きます

Blackholeのアニメは、最初はBlackholeHidedになるので、ブラックホールは表示されていません。

- AnimatorウィンドウでParametersタブを選択します
- Spawnにチェックを入れます

アニメーションの動きを確認できます。チェックを外すと、消えるアニメーションが再生されます。

# 操作を実装する
操作を実装します。

## プレハブの準備
Blackholeのプレハブに以下を設定ます。

- 新規にBlackholeというスクリプトを作成してアタッチ
- Rigidbody2Dをアタッチして、以下を設定
  - Gravity Scaleを0にして重力を消す
- Circle Collider 2Dをアタッチして、以下を設定
  - Is Triggerにチェック
- TagとLayerにBlackholeを定義して設定

## スクリプトの実装
先にまとめた状態をはじめ、必要な変数やプロパティーを宣言します。

- Rigidbody2DとAnimatorのインスタンスをキャッシュする変数
- 操作が可能な時にtrueを返すboolフラグ`CanMove`
- エネルギーの値`Energy`。とりあえず100で初期化しておく
- 後程、ぐらびぃで利用するためのブラックホールの発生状態を表すフラグ`IsSpawned`

Awake()で、Rigidbody2DとAnimatorのインスタンスを取得します。
